---
title: 缓存投毒和缓存欺骗
date: 2019-03-18 19:02:44
tags:
- 缓存投毒
- 缓存欺骗
- HTTP
---
参考文章
原帖：https://portswigger.net/blog/practical-web-cache-poisoning
翻译帖子：
- https://www.anquanke.com/post/id/156356
- https://www.anquanke.com/post/id/156551
<!--more-->
分析下缓存投毒：从投毒原理，投毒面，投毒时机，投毒方法来简单阐述。
以及对于缓存欺骗，因为在上次CTF比赛中遇到了缓存投毒，而没有碰到缓存欺骗，所以只能进行一些学习了，缓存投毒也是学习哈哈哈。
还有最后的Web缓存控制策略详解，涉及到缓存方面的一些知识点。

# 缓存投毒

## 投毒原理
![](/images/19-3-18_缓存投毒_投毒原理1.svg)

**实现原因**
简单阐述就是服务端把客户端第一次请求的页面缓存到软件公司的服务器上。客户端请求一个url，服务端会查询是否存在缓存，存在的话，则由软件公司根据用户的不同发送不同的缓存文件。如果我们找到一个网页存在存储型XSS，并且此网页可缓存到软件公司。如果我们成功构造一个已经缓存到服务器上的XSS页面。其他人访问此页面的时候，就有可能(如果软件公司觉得他和你是同一类人)遭受到XSS攻击。

**实现过程**
![](/images/19-3-18_缓存投毒_投毒原理2.svg)

1. 找到一个输入点(非缓存键)，我们可以构造恶意代码。
2. 尝试将其缓存，页面是否被缓存可以基于多种因素，包括文件扩展名，内容类型，路由，状态代码和响应头。
3. 缓存投毒工具：[Param Miner](https://github.com/PortSwigger/param-miner)

## 投毒面
应该是所有允许缓存的过程中都有被投毒的可能。搜索可知在16年就存在这个概念，最早也不知在什么时候提出的。
![](/images/19-3-18_缓存投毒_投毒面1.png)

## 投毒时机
1. 我们需要确保在缓存的响应过期后我们发送的请求第一个达到主页。响应头“Age”和“max-age”分别指定当前响应的时间和它将过期的时间。
- `Age`当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 
- `max-age=xxx`表示还剩下多少秒过期；
- `max-age=0`表示无论如何，先检验`Etag/Last-Modified`
更多可以查看：http://www.laruence.com/2010/03/05/1332.html
2. 在上次的CTF比赛中，遇到的一道题目，对于每一个账户的profile页面都存在缓存，并且profile页面存在xss。但是知识`self-XSS`;所以构造一个name为`.js`结尾的账户，就可以成功投毒，构造一个存在XSS的页面。并让管理员查看该页面，可以成功打XSS。（其实感觉有点像缓存欺骗的）

## 投毒方法
**确定缓存键或者非缓存键**

缓存键是缓存的关键，非缓存键是缓存恶意代码的关键。
1. Vary头定义了可能的缓存键，但是不一定，Cloudflare就忽略这个头。但是可以作为一种尝试。还有文件扩展名，内容类型，HTTP头等等。HTTP在作者的文章中占有相当大的比例，有以下几个http头：
	- X-Forwarded-Host: 
	- X-Forwarded-Server:HubSpot
	- X-Original-URL
	- X-Rewrite-URL

**投毒手段**
1. DOM 投毒
`{"Show more":"<svg onload=alert(1)>"}`
2. 重定向
3. XSS

一次投毒视频：https://portswigger.net/cms/videos/5b/fe/e952b9f0eb55-drupaldemo.mp4 

## 绕过缓存投毒防御措施：
参考文章：https://portswigger.net/blog/bypassing-web-cache-poisoning-countermeasures4
- 添加多个相同的头
![](/images/19-3-18_缓存投毒_投毒绕过1.png)
- 加端口
![](/images/19-3-18_缓存投毒_投毒绕过2.png)

在文中有这么一句话： it’s worth noting that the mitigation won’t ever make sites hosted on Cloudflare immune to cache poisoning in general - it only prevents attacks using the most popular headers. 
这也恰好印证了上次CTF比赛中的投毒面在于<select>框。

# 缓存欺骗
原文链接：https://omergil.blogspot.com/2017/02/web-cache-deception-attack.html?tdsourcetag=s_pcqq_aiomsg

举文章中的例子简单介绍下：
1. Browser requests http://www.example.com/home.php/non-existent.css.
2. Server returns the content of http://www.example.com/home.php, most probably with HTTP
3. caching headers that instruct to not cache this page.
4. The response goes through the proxy.
5. The proxy identifies that the file has a css extension.
6. Under the cache directory, the proxy creates a directory named home.php, and caches the imposter "CSS" file (non-existent.css) inside.
附一张图：
![](/images/19-3-18_缓存欺骗1.png)

我认为关键在于发送的proxy的URL路径没有改变，所以导致proxy识别为css文件。因此缓存了此文件。
这里我自己举个例子，我认为算是缓存欺骗＋缓存投毒
上次CTF比赛的题目中，注册一个`.js`结尾的账户。profile的页面的URL就变成了`http://xxx.com/profile/xxx.js`。因此构造了缓存欺骗，但是只是没有泄露隐私信息，泄露了构造的xss代码...然后proxy缓存了此页面；但是返回的页面为什么会执行js代码呢，猜测就像是linux中万物皆为文件，文件名可以随意定制。这里虽说是`.js`结尾，但是采用的是html去解析这个页面。具体怎么把页面当作html来解析的，太菜了，想象不出来。

# Web缓存控制策略详解
参考：[luochicun](https://mp.weixin.qq.com/s?__biz=MzI0MDY1MDU4MQ==&mid=2247492012&idx=2&sn=fccbbab0a815d46033179e10fe994c4a&chksm=e9153196de62b8804412dff3f94000cd82056e5bd20de55411e7f4323c76df8a77b75db9ec33&xtrack=1&scene=0&subscene=131&clicktime=1552958485&ascene=7&devicetype=android-26&version=2700033b&nettype=3gnet&abtest_cookie=AwABAAoACwATAAQAI5ceAFaZHgDFmR4A3JkeAAAA&lang=zh_CN&pass_ticket=7o0lExrTyQWuT94FE38wnnXWgn%2BvcX3OozbZyFmRm7X2tJ7bOoDW%2BjTSLSy6rrgs&wx_header=1&tdsourcetag=s_pcqq_aiomsg)

缓存方面最常用和有效的方法Cache-Control这个HTTP头。文章讨论的方面是此头的指令用法及作用。

## public和private缓存
**public**
任何缓存服务器都可以存储响应的副本，包括CDN、代理服务器等等。

**private**
只有客户端或浏览器才可以存储该文件的副本。

## max-age
max-age定义了一个以秒为单位的时间单位(相对于请求的时间)，该单位的响应被认为是`fresh`

举个例子：`Cache-Control: max-age=60`
此Cache-Control标头会告诉浏览器，它可以在接下来的60秒内使用缓存中的此文件，而不必担心重新被验证。 不过60秒后，浏览器将返回服务器以重新验证文件。

如果服务器有一个新文件供浏览器下载，它将以200响应进行响应，下载新文件后，旧文件将从HTTP缓存中弹出，新文件将替换它，并将成为新的缓存标头。

如果服务器没有需要下载的更新副本，则服务器将以200响应进行响应，不需要下载任何新文件，并将使用新的标头更新缓存副本。这意味着，如果仍然存在Cache-Control：max-age = 60标头，则缓存文件在60秒后将再次启动。算下来，一个文件的总缓存时间为120秒。

注意：max-age会有自动警告的属性，如果浏览器过于陈旧，则max-age会提醒用户，但用户可以选择忽略此警告。浏览器可能会使用自己的试探法来决定是否在不重新验证文件的情况下发布文件的陈旧副本。这种行为有些不确定，所以很难确切地知道浏览器将实际做什么。为此，我们有一系列显式指令，可以用它们来扩充max-age。

## s-maxage

s-maxage将优先于max-age指令，但仅限在共享缓存的上下文中使用。将max-age和s-maxage结合使用，你可以分别为private和public缓存（例如代理、CDN）提供不同的启动时间。

## no-store

`Cache-Control: no-store`

如果我们不想缓存文件怎么办？如果文件包含敏感信息怎么办？也许这是一个包含银行详细信息的HTML页面？或许这些信息对时间至关重要？也许是一个包含实时股票价格的页面？其实我们并不想在缓存中存储或提供任何类似的响应：我们总是希望丢弃敏感信息并获取最新的实时信息。这时，我们就要用到no-store指令。

no-store是一个非常强大的指令，不会将任何信息保存到任何缓存中，无论是private或其他缓存。

## no-cache
这是让大多数人误解的指令，no – cache存并不意味着“没有缓存”。

无缓存的一个很好的用例几乎就是动态HTML页面，想想新闻网站的主页：它不是实时的，也不包含任何敏感信息，但理想情况下我们希望页面始终显示最新鲜的内容。我们可以使用cache-control：no-cache来指示浏览器首先检查服务器，如果服务器没有更新的东西（304），就会重用缓存的版本。如果服务器确实有一些更新鲜的内容，它会响应（200）并发送更新的文件。

提示：没有必要发送max-age指令和no-cache指令，因为重新验证的时间限制为零秒。

## must-revalidate

`Cache-Control: must-revalidate, max-age=600`
must-revalidate需要一个相关的max-age指令，如上所示，我们把它设置为十分钟。此时，no-cache将立即与服务器重新验证，只有在服务器允许时才使用缓存副本时，must-revalidate才类似于一个宽限期no-cache。具体过程是这样的，在前十分钟，浏览器不会与服务器重新验证，但十分钟过后，它又返回服务器。如果服务器没有任何新内容，它将以304响应并且新的Cache-Control标头应用于缓存文件。然后再以十分钟为单位，如果在十分钟之后，服务器上有一个较新的文件，我们会收到200响应及其正文，并且本地缓存会更新。

## proxy-revalidate

与s-maxage类似，proxy-revalidate是must-revalidate的public缓存的自定义版本，它只是被private缓存忽略了。

## immutable

immutable是一个非常新的且非常简洁的指令，它告诉浏览器关于我们发送的文件类型的更多信息，该指令可以解决以下问题:用户刷新会导致浏览器重新验证文件，无论其新鲜度如何，用户刷新通常意味着以下任意情况必定发生：页面看起来不完整或者内容还和原来一样。

所以，我们有必要检查服务器上是否有更新的内容。

如果服务器上有更新的文件，我们肯定希望下载它。因此，我们将得到200响应，即一个新文件出现。但是，如果服务器上没有新文件，我们将得到304响应，即没有新文件，如果是专业，则整个延迟反应就没有意义了。如果我们重新验证许多导致延迟反应304的文件，可能会增加数百毫秒不必要的等待。

immutable是一种告诉浏览器文件有无可变内容的指令，如果内容无更新，则永远不会重新验证缓存。这样，就可以完全消除延迟时间。不过，immutable所指的可变或不可变文件的具体含义是什么？

style.css：当我们更改此文件的内容时，即使根本不更改其名称，这个文件也被认为是可变的。

style.ae3f66.css：这个文件是唯一的，它以基于其具体内容来命名的，所以一旦内容发生变化，我们就会得到一个全新的文件，此时，这个文件就被认为是不可变的。

我们将在Cache Busting部分中更详细地讨论这个问题。

如果我们能够以某种方式向浏览器发出文件是不可变的信号，则它就不需要检查更新版本，这正是immutable指令的作用：

`Cache-Control: max-age=31536000, immutable`

在支持immutable指令的浏览器中，用户刷新永远不会在31536000秒的新鲜度生命周期内进行重新验证。这意味着无需花费不必要的延迟时间来检索304响应，这可能会在关键路径（CSS blocks rendering）上节省大量的延迟时间。

注意：你不应该将immutable应用于任何不可变的文件，因为你还应该有一个非常强大的缓存破坏策略。

## stale-while-revalidate

stale-while-revalidate提供的是宽限期，在此期间，当我们检查新版本时，允许浏览器使用过去的缓存。

`Cache-Control: max-age=31536000, stale-while-revalidate=86400`

该指令是在告诉浏览器“这个文件可以使用一年，一年之后，还可以再用一个星期。在这时候，如果你要继续使用这个旧的资源，就必须在后台重新验证它”。

stale-while-revalidate对非关键资源是一个很好的指令，当然，我们希望使用最新的版本。但是我们知道，如果在检查更新时再次使用过时的响应，不会造成任何对更新的破坏。

## stale-if-error

与stale-while-revalidate类似，如果重新验证的资源返回5xx类错误，stale-if-error允许浏览器有一段缓冲时间，在此期间可以允许返回过时的响应。

`Cache-Control: max-age=2419200, stale-if-error=86400`

在本文中，我们指定了28天（2419200秒）以内的缓存文件都是新的，如果我们在那之后遇到更新错误，我们会多追加一天（86400秒），在此期间我们将允许过时的资源响应。

## Cache Busting（缓存破坏）
Cache busting就是强制浏览器下载新文件的一种方法，通过将新文件的名字修改成和旧文件不同的名字即可实现。

此方法的关键是更改文件名，但不一定是对指纹进行更改。以下所有示例都具有相同的效果：

- `/assets/style.ae3f66.css`：使用文件内容的哈希产生破坏；

- `/assets/style.1.2.14.css`：使用一个已发布的版本产生破坏；

- `/assets/1.2.14/style.css`：通过更改URL中的目录产生破坏；

但是，最后一个示例表明，我们对每个版本而不是每个单独的文件进行版本控制。这反过来意味着，如果我们只需要缓存样式表，则还必须缓存该版本的所有静态文件，所以首选选项是前两个。

# http0.9投毒
https://blog.wonderkun.cc/2019/04/15/plaidCTF%E4%B8%A4%E9%81%93web%E9%A2%98%E7%9B%AEwriteup/